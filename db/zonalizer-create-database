#!/usr/bin/env perl

use common::sense;

use AnyEvent;
use AnyEvent::CouchDB;
use AnyEvent::HTTP;
use JSON;
use OSSP::uuid;
use Getopt::Long;

STDOUT->autoflush(1);

my $drop = 0;
my $create = 0;
my $test = 0;

GetOptions(
    'drop' => \$drop,
    'create' => \$create,
    'test' => \$test
);

unless ( $ARGV[0] ) {
    die 'usage: zonalizer-create-database [--drop|--create|--test] <uri>'
}

my $JSON = JSON->new;
my $db   = couchdb( $ARGV[0] );

if ( $drop ) {
    $db->drop->recv;
}
if ( $drop or $create ) {
    $db->create->recv;
}

foreach ( keys %{schema()} ) {
    if ( $drop or $create ) {
        say 'Creating ', $_;
    }
    else {
        my $doc;
        eval {
            $doc = req( GET => $_ )->recv;
        };

        unless ( $@ ) {
            say 'Recreating ', $_;

            $doc = $JSON->decode($doc);
            unless ( ref($doc) eq 'HASH' and $doc->{_rev} ) {
                die 'Unexpected return or missing data from CouchDB when reading design';
            }
            req( DELETE => $_.'?rev='.$doc->{_rev} )->recv;
        }
        undef $@;
    }
    req( PUT => $_, $JSON->encode( {
        %{ schema()->{$_} },
        _id => $_
    } ) )->recv;
}

print 'Checking objects ... ';
my $skip = 0;
my $changed = 0;

while ( 1 ) {
    my $list = req( GET => '_design/analysis/_view/all?include_docs=true&limit=5&skip='.$skip )->recv;
    $list = $JSON->decode( $list );
    unless ( ref($list) eq 'HASH'
        and defined $list->{total_rows}
        and defined $list->{offset}
        and ref($list->{rows}) eq 'ARRAY' )
    {
        die 'Unexpected return or missing data from CouchDB when listing analysis';
    }

    my @docs;
    foreach ( @{$list->{rows}}) {
        unless ( ref($_) eq 'HASH'
            and defined $_->{id}
            and ref( $_->{doc}) eq 'HASH' )
        {
            die 'Unexpected return or missing data from CouchDB when reading list of analysis';
        }

        push(@docs, $_->{doc});
    }

    foreach (@docs) {
        if ( check( $_ ) ) {
            $db->save_doc( $_ )->recv;
            $changed++;
        }

        $skip++;
        print "\r", 'Checking objects ... ', $skip, ' / ', $list->{total_rows}, ' (changed: ', $changed, ')';
    }

    unless ( $skip < $list->{total_rows} ) {
        say;
        last;
    }
}

exit;

sub check {
    my ( $doc ) = @_;
    my $changed = 0;

    if ( ref($doc->{results}) eq 'ARRAY' ) {
        foreach ( @{$doc->{results}}) {
            if ( exists $_->{message} ) {
                delete $_->{message};
                $changed = 1;
            }
        }
    }

    return $changed;
}

sub schema {
    return {
        '_design/new_analysis' => {
            views => {
                all => {
                    map => '
function (doc) {
    if (doc.type == "new_analyze" || doc.type == "analyze") {
        emit(doc.id);
    }
}
'
                },
                only => {
                    map => '
function (doc) {
    if (doc.type == "new_analyze") {
        emit(doc.id);
    }
}
'
                }
            }
        },
        '_design/analysis' => {
            views => {
                all => {
                    map => '
function (doc) {
    if (doc.type == "analyze") {
        emit([doc.id, null]);
    }
}
'
                },
                map( {
                    'by_' . $_ => {
                        map => '
function (doc) {
    if (doc.type == "analyze") {
        emit([doc.' . $_ . ', doc.id, null]);
    }
}
'
                      }
                } ( qw(fqdn created updated) ) ),
#                fqdn => {
#                    map => '
#        function (doc) {
#            if (doc.type == "analyze") {
#                var key = doc.fqdn.split(/\./).reverse();
#                key.push(null);
#                emit([key, doc.id, null]);
#            }
#        }
#        '
#                },
#                map( {
#                    'fqdn_by_' . $_ => {
#                        map => '
#        function (doc) {
#            if (doc.type == "analyze") {
#                var key = doc.fqdn.split(/\./).reverse();
#                key.push(null);
#                emit([key, doc.' . $_ . ', doc.id, null]);
#            }
#        }
#        '
#                      }
#                } ( qw(created updated) ) )
            }
        }
    };
}

sub req {
    my ( $method, $path, $body ) = @_;
    my $cv = AnyEvent->condvar;

    http_request(
        $method => $db->uri . $path,
        headers => $db->_build_headers( {
            $method eq 'POST' || $method eq 'PUT'
            ? (
                'Content-Type' => 'application/json'
            )
            : (),
        } ),
        body    => $body,
        sub {
            my ( $body, $headers ) = @_;
            if ( $headers->{Status} >= 200 and $headers->{Status} < 400 ) {
                $cv->send( $body );
            }
            else {
                $cv->croak( $db->uri . $path . ': ' . $headers->{Status} . ' - ' . $headers->{Reason} . ' - ' . $headers->{URL} );
            }
        }
    );

    return $cv;
}

=head1 NAME

zonalizer-create-database - Create the CouchDB database for Zonalizer

=head1 SYNOPSIS

zonalizer-create-database <uri>

=head1 AUTHOR

Jerry Lundström, C<< <lundstrom.jerry@gmail.com> >>

=head1 BUGS

Please report any bugs or feature requests to L<https://github.com/jelu/lim-plugin-zonalizer/issues>.

=head1 SUPPORT

You can find documentation for this module with the perldoc command.

    perldoc Lim::Plugin::Zonalizer

You can also look for information at:

=over 4

=item * Lim issue tracker (report bugs here)

L<https://github.com/jelu/lim-plugin-zonalizer/issues>

=back

=head1 ACKNOWLEDGEMENTS

=head1 LICENSE AND COPYRIGHT

Copyright 2015 Jerry Lundström
Copyright 2015 IIS (The Internet Foundation in Sweden)

This program is free software; you can redistribute it and/or modify it
under the terms of either: the GNU General Public License as published
by the Free Software Foundation; or the Artistic License.

See http://dev.perl.org/licenses/ for more information.

=cut
